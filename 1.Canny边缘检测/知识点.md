[TOC]



#### 一、图像噪声

##### 1、椒盐噪声

椒盐噪声（Salt-and-pepper noise）是数字图像处理中的一种常见噪声类型，它通常是由于**数据采集或传输过程中的误差引起的**。这种噪声会在图像中**产生随机的黑色和白色像素点，从而破坏了图像的质量和清晰度**。椒盐噪声的名称源自于黑白相间的小颗粒，就像是撒上了椒盐一样。在数字图像处理中，我们通常会使用滤波器等技术来减少或消除椒盐噪声的影响，以提高图像的质量和清晰度。

##### 2、高斯噪声

高斯噪声（Gaussian noise）是数字图像处理中的另一种常见噪声类型，也被称作白噪声（White noise）。它是由于环境干扰、电子元件本身的随机性等因素所引起的一种随机误差信号，其**在时域和频域上均符合高斯分布**，因此也被称为正态分布噪声。与椒盐噪声不同，**高斯噪声在图像中产生的是随机强度值的变化，这些强度值通常呈现为较小的连续变化，而不是像椒盐噪声那样出现孤立的黑白像素点。**在数字图像处理中，我们通常会使用滤波器等技术来减少或消除高斯噪声的影响，以提高图像的质量和清晰度。常用的方法包括**平滑滤波和高斯滤波**等。高斯随机变量z的概率密度函数由下式给出
$$
p(z)=\frac{1}{\sqrt{2 \pi} \sigma} e^{\frac{-(z-\mu)^2}{2 \sigma^2}}
$$
其中z表示灰度值，μ表示z的平均值或期望值，σ表示z的标准差。

#### 二、图像平滑

图像平滑（Image smoothing）它可以消除图像中的噪声和细节，从而减少图像中的不连续性并使其更加平滑。在实际应用中，图像平滑通常被用来**预处理图像**，以便提高后续处理步骤的效果和精度。

图像平滑从信号处理的角度看就是**去除其中的高频信息，保留低频信息**。对于图像来说，高频分量主要体现在边缘、纹理等细节信息上，而低频分量则是图像中的整体亮度和颜色分布等基本属性。在图像平滑过程中，我们使用低通滤波器去除了图像中频率较高的部分，也就是去除了图像中的高频信息，保留了低频信息，因此得到了更加平滑的图像结果。

平滑操作基于一个滤波器（也称为卷积核）对图像进行**卷积处理**，每个像素点的灰度值会被加权平均到周围像素上，从而产生一种模糊或柔和的效果。平滑滤波器通常采用局部加权平均法，即对周围像素的灰度值进行加权平均，以获得当前像素点的新灰度值。其中，加权系数或权重通常是关于距离或位置的函数，例如高斯函数等。

常见的图像平滑方法包括均值平滑、中值平滑、高斯平滑等。其中，均值平滑是最简单的平滑滤波器之一，它的权重系数相等，可以有效地抑制噪声；**中值平滑适用于消除椒盐噪声**等存在孤立像素的噪声类型；**高斯平滑则可以提供更好的噪声抑制和边缘细节保留效果**。

##### 1、均值滤波

均值滤波器可表示为：
$$
\hat{f}(x, y)=\frac{1}{m n} \sum_{(s, t) \in S_{x y}} g(s, t)
$$
令S_xy 表示中心在(x, y)点，尺寸为m×n 的矩形子图像窗口的坐标组。 

```python
# API
cv2.blur(src, ksize, anchor, borderType)`
# src：输入图像
# ksize：卷积核的大小`
# anchor：默认值 (-1,-1) ，表示核中心`
# borderType：边界类型
```

**均值滤波的优点是算法简单，计算速度较快，缺点是在去噪的同时去除了很多细节部分，将图像变得模糊。**

##### 2、高斯滤波

***用于去除高斯噪声***。二维高斯是构建高斯滤波器的基础，其概率分布函数如下所示
$$
G(x, y)=\frac{1}{2 \pi \sigma^2} \exp \left\{-\frac{x^2+y^2}{2 \sigma^2}\right\}
$$
当σ取值越大，整个形状趋近于扁平；当σ取值越小，整个形状越突起。随着滤波器函数σ的增大，图像的细节(高频部分)逐渐被滤除，图像的尺度依次变大。

主要思路：**正态分布是一种钟形曲线，越接近中心，取值越大，越远离中心，取值越小。计算平滑结果时，只需要将"中心点"作为原点，其他点按照其在正态曲线上的位置，分配权重，就可以得到一个加权平均值**。

```python
# API
cv2.GaussianBlur(src,ksize,sigmaX,sigmay,borderType)
# src: 输入图像
# ksize:高斯卷积核的大小，卷积核的宽度和高度都应为奇数，且可以不同
# sigmaX: 水平方向的标准差
# sigmaY: 垂直方向的标准差，默认值为0，表示与sigmaX相同
# borderType:填充边界类型
```

##### 3、中值滤波

***用于去除椒盐噪声***。中值滤波对椒盐噪声尤其有用是因为椒盐噪声通常是由于随机的孤立像素点所引起的，它会使图像中出现一些非常亮或非常暗、与周围像素差异很大的像素点，从而破坏了图像的质量和清晰度。而中值滤波正是通过取卷积区域内像素的中值来进行滤波处理的，这种方法可以有效地消除这些孤立的像素点，从而减少图像中的噪声，并且不会破坏图像的边缘和细节信息。相比之下，均值滤波和高斯滤波等线性滤波器在处理椒盐噪声时并不那么有效，因为它们在滤波过程中只是简单地对周围像素进行加权平均，无法区分椒盐噪声和真实的图像纹理信息，从而可能导致图像中出现模糊或失真的区域。

```python
# API：
cv2.medianBlur(src, ksize )
# src：输入图像
# ksize：卷积核的大小
```



#### 三、高斯滤波锐化

##### 1、高斯滤波锐化的步骤

- 利用高斯滤波对图像进行滤波得到低频图像;
- 再用原始图像减去低频图像得到细节图像;
- 然后将对细节图像进行加权后加回到原始图像中得到高斯滤波锐化图像





#### 四、图像直方图。

##### 1、图像直方图

图像直方图（Image Histogram）是用以表示数字图像中亮度分布的直方图，标绘了图像中每个亮度值的像素个数。

直方图的一些术语和细节：

- dims：需要统计的特征数目。如果仅仅统计了灰度值，dims = 1 。
- bins：每个特征空间子区段的数目，可译为 “直条” 或 “组距”。
- range：要统计特征的取值范围。在上例中，range = [0, 255]。

```python
# API：
cv2.calcHist(images,channels,mask,histSize,ranges[,hist[,accumulate]])

# images: 原图像。当传入函数时应该用中括号 [] 括起来，例如：[img]。
# channels: 如果输入图像是灰度图，它的值就是 [0]；如果是彩色图像的话，传入的参数可以是 [0]，[1]，[2] 它们分别对应着通道 B，G，R。 　　
# mask: 掩模图像。要统计整幅图像的直方图就把它设为 None。但是如果你想统计图像某一部分的直方图的话，你就需要制作一个掩模图像，并使用它。　　
# histSize:BIN 的数目。也应该用中括号括起来，例如：[256]。 　　
# ranges: 像素值范围，通常为 [0，256]
```

##### 2、掩膜

掩膜（Mask）是一种用于图像处理和计算机视觉中的技术，它可以通过将一个特定形状的透明覆盖在图像的某个区域上来**隐藏或突出显示该区域**。掩膜通常采用二值图像，其中1表示要保留的区域，0表示要遮挡的区域。使用cv.calcHist（）来查找完整图像的直方图，如果要查找图像某些区域的直方图，只需在要查找直方图的区域上创建一个白色的掩膜图像，否则创建黑色， 然后将其作为掩码mask传递即可。一种创建掩膜的方法

```python
# 全黑即全0矩阵
mask = np.zeros(img.shape[:2], np.uint8)
# 感兴趣区域置1，得到掩膜，calcHist里面的mask是这个，不是下面的
mask[400:650, 200:500] = 255
# 掩膜后的图
masked_img = cv.bitwise_and(img,img,mask = mask)
```



##### 3、直方图均衡化

直方图均衡化是一种用于图像处理的技术，主要**用于增强图像的对比度**。它可以将一幅图像的像素值重新分布，使得像素值更加平均分布，从而提高图像的视觉效果和质量。**相当于将直方图做一个横向拉伸，扩大图像像素值的分布范围，从而提高图像的对比度**。

```python
# API：
dst = cv.equalizeHist(img)
# img: 灰度图像
# dst : 均衡化后的结果
```

**自适应的直方图均衡化是为了解决什么问题**

自适应的直方图均衡化（Adaptive Histogram Equalization，AHE）是为了解决全局直方图均衡化算法在处理具有多种光照条件的图像时可能出现过度增强或欠增强的问题。全局直方图均衡化算法是将整个图像的直方图拉伸到一定范围内，以扩展亮度动态范围，提高对比度和细节信息。但这种方法无法考虑图像中不同区域的光照差异，可能会导致一些区域过度增强而另一些区域欠增强，使图像质量下降。因此，自适应的直方图均衡化通过**在图像中局部进行直方图均衡化**，可以**更好地保留图像细节和颜色平衡**，并且避免了过度增强或欠增强的问题，从而提高了图像的视觉质量。

**为什么自适应的直方图均衡化需要对比度限制**

对比度限制是指对直方图均衡化的结果进行限制，以防止过度增强局部细节和噪声的影响。具体来说，在进行自适应的直方图均衡化时，我们可以根据每个小区域内像素值的分布情况，确定一个对比度限制参数，使得处理后的图像的像素值范围不会过于集中或过于分散，同时还能保留较多的图像细节信息。

```python
# API：
cv.createCLAHE(clipLimit, tileGridSize)
# clipLimit: 对比度限制，默认是40
# tileGridSize: 分块的大小，默认为8*8
```

#### 五、边缘检测

##### 1、边缘的特征

***边缘是图像强度函数中快速变化的地方***。图像边缘检测大幅度地减少了数据量，并且剔除了可以认为不相关的信息，**保留了图像重要的结构属性**。有许多方法用于边缘检测，它们的绝大部分可以划分为两类：基于搜索和基于零穿越。

- 基于搜索：通过寻找图像**一阶导数中的最大值**来检测边界，然后利用计算结果估计边缘的局部方向，通常采用梯度的方向，并利用此方向找到**局部梯度模的最大值**，代表算法是Sobel算子和Scharr算子。
- 基于零穿越：通过寻找图像**二阶导数零**穿越来寻找边界，代表算法是Laplacian算子。

##### 2、sobel算子

一阶导数有
$$
f^{ \prime}(x)=\{f(x+1)-f(x-1)\}/2
$$
假设要处理的图像为 I ，需要两个方向求导:

**水平变化**: 将图像 I 与奇数大小的模版进行卷积，结果为Gx，比如，当模板大小为3时, Gx为:
$$
G_x=\left[\begin{array}{lll}
-1 & 0 & +1 \\
-2 & 0 & +2 \\
-1 & 0 & +1
\end{array}\right] * I
$$
**垂直变化**: 将图像 I 与奇数大小的模板进行卷积，结果为Gy。比如，当模板大小为3时, Gy为:
$$
G_y=\left[\begin{array}{lll}
-1 & -2 & -1 \\
 0 &  0 &  0 \\
+1 & +2 & +1
\end{array}\right] * I
$$

```python
# API
Sobel_x_or_y = cv2.Sobel(src, ddepth, dx, dy, dst, ksize, scale, delta, borderType)
# src：传入的图像
# ddepth: 图像的深度
# dx和dy: 指求导的阶数，0表示这个方向上没有求导，取值为0、1。
# ksize: 是Sobel算子的大小，即卷积核的大小，必须为奇数1、3、5、7，默认为3。
# 注意：如果ksize=-1，就演变成为3x3的Scharr算子。
# scale：缩放导数的比例常数，默认情况为没有伸缩系数。
# borderType：图像边界的模式，默认值为cv2.BORDER_DEFAULT。
```

**注意：**Sobel函数求完导数后会有负值，还有会大于255的值。而原图像是uint8，即8位无符号数，所以Sobel建立的图像位数不够，会有截断。因此要使用16位有符号的数据类型，即cv2.CV_16S。处理完图像后，再使用cv2.convertScaleAbs()函数将其转回原来的uint8格式，否则图像无法显示。Sobel算子是在两个方向计算的，最后还需要用cv2.addWeighted( )函数将其组合起来。



##### 3、Laplacian算子(拉普拉斯算子)

Laplacian是利用二阶导数来检测边缘 。 因为图像是 “2维”, 我们需要在两个方向求导，如下式所示：
$$
∇^2f = ∂^2f/∂x^2 + ∂^2f/∂y^2
$$
那不连续函数的二阶导数是：
$$
f^{\prime \prime}(x)=f^{\prime}(x+1)-f^{\prime}(x)=f(x+1)+f(x-1)-2 f(x)
$$
那使用的卷积核是：
$$
kernel=\left[\begin{array}{lll}
0 & 1 & 0 \\
 1 &  -4 &  1 \\
0 & 1 & 0
\end{array}\right]
$$

```python
# API：
laplacian = cv2.Laplacian(src, ddepth[, dst[, ksize[, scale[, delta[, borderType]]]]])
# Src: 需要处理的图像，
# Ddepth: 图像的深度，-1表示采用的是原图像相同的深度，目标图像的深度必须大于等于原图像的深度；
# ksize：算子的大小，即卷积核的大小，必须为1,3,5,7。
```

##### 4、图像的深度

在图像处理中，深度指的是每个像素点可以表示的颜色数量。深度越高，图像的颜色细节就越丰富，能够显示更多的颜色。比如，黑白图像的深度为1位，表示每个像素只有黑和白两种颜色；灰度图像的深度为8位，表示每个像素可以表示256种不同的灰度值；而彩色图像一般有24位或32位的深度，即每个像素可以表示约1670万种不同的颜色。

需要注意的是，深度与图像分辨率没有直接关系。图像分辨率指的是图像中所包含的像素数量，而深度则是每个像素可以表示的颜色数量。因此，即使两张图像的分辨率相同，但如果它们的深度不同，它们的颜色细节也会有所差异。

##### 5、Canny边缘检测

**Canny算子进行边缘检测的步骤**

1. 用高斯导数做滤波

   Canny算子进行边缘检测时，先使用高斯滤波器对图像进行滤波是为了**平滑图像并减少噪声**的影响。因为在进行边缘检测时，存在一些噪点或细节会干扰到边缘的检测结果，而高斯滤波器可以有效地去除这些噪声和细节。另外，高斯滤波器还能够使图像变得更加平滑，在边缘检测时有助于将真正的边缘从噪声、纹理等其他信息中分离出来，得到更准确的边缘检测结果。同时，使用高斯滤波器进行平滑处理还能够使得后续的梯度计算更加稳定和可靠，避免由于噪声等因素产生的不必要误差。

2. 获得梯度的幅值与方向

   对平滑后的图像使用 Sobel 算子计算水平方向和竖直方向的一阶导数（Gx 和 Gy）。根据得到的这两幅梯度图（Gx 和 Gy）找到边界的**梯度和方向**。
   $$
    Edge(G)=\sqrt{G_x^2+G_y^2} \\
   \operatorname{Angle}(\theta)=\tan ^{-1}\left(\frac{G_y}{G_x}\right)
   $$
   
3. 非最大值抑制

   在获得梯度的方向和大小之后，对整幅图像进行扫描，去除那些非边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。如下图所示：

4. 连接与滞后阈值化

   定义两个阈值，低和高。使用高阈值寻找边缘曲线的起点，用低阈值确定后继点。现在要确定真正的边界。 我们设置两个阈值： minVal 和 maxVal。 当图像的灰度梯度高于 maxVal 时被认为是真的边界， 低于 minVal 的边界会被抛弃。**如果介于两者之间的话，就要看这个点是否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。**

   

```python
# API:
canny = cv2.Canny(image, threshold1, threshold2)
# image:灰度图，
# threshold1: minval，较小的阈值将间断的边缘连接起来
# threshold2: maxval，较大的阈值检测图像中明显的边缘
```

##### 6、总结

1. Sobel算子的优点是计算速度快，可以实时应用于视频流等实时处理场景。缺点是容易受到噪声的干扰，且只能检测水平和垂直方向上的边缘。
2. Laplacian算子的优点是能够检测出图像中的所有边缘，且不易受到噪声的影响。缺点是容易产生较强的噪声响应，需要进行后续处理。
3. Canny算子的优点是准确性高，对噪声有良好的抑制效果，能够检测出任意方向的边缘。缺点是算法复杂度较高，计算速度较慢。

如果需要实时处理并且只关注水平和垂直方向上的边缘，那么Sobel算子是一个不错的选择；如果需要检测任意方向的边缘，并且对准确性有更高的要求，那么Canny算子是一个更好的选择；如果需要检测出图像中的所有边缘，并且不怕噪声干扰，那么Laplacian算子可能更适合。